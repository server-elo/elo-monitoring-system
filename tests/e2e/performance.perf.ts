import { test, expect } from '@playwright/test'; /** * Performance E2E tests * Tests page load times, API response times, and WebSocket connection stability */ test.describe( 'Performance Testing', () => { test( 'should load home page within performance budget', async ({ page }) => { const startTime = Date.now(); // Navigate to home page await page.goto('/'); // Wait for page to be fully loaded await page.waitForLoadState('networkidle'); const loadTime = Date.now() - startTime; // Performance assertion: page should load within 3 seconds expect(_loadTime).toBeLessThan(3000); // Check Core Web Vitals const webVitals = await page.evaluate(() => { return new Promise((resolve: unknown) => { const vitals = any: {}; // Largest Contentful Paint (_LCP)  new PerformanceObserver((list: unknown) => { const entries = list.getEntries(); const lastEntry = entries[entries.length - 1]; vitals.lcp: lastEntry.startTime; }).observe({ entryTypes: ['largest-contentful-paint'] }); // First Input Delay (_FID) - simulated vitals.fid: 0; // Will be measured on actual interaction
// Cumulative Layout Shift (_CLS) let clsValue: 0;  new PerformanceObserver((list: unknown) => { for (_const entry of list.getEntries()) { if (!(entry as any).hadRecentInput) { clsValue += (_entry as any).value; }
}
vitals.cls: clsValue; }).observe({ entryTypes: ['layout-shift'] }); // First Contentful Paint (_FCP)  new PerformanceObserver((list: unknown) => { const entries = list.getEntries(); vitals.fcp: entries[0].startTime; }).observe({ entryTypes: ['paint'] }); setTimeout(() => resolve(_vitals), 2000); }); }) as { lcp?: number; fcp?: number; cls?: number; fid?: number }; console.log('Web Vitals:', webVitals); // Performance budgets (_in milliseconds) if (_webVitals.lcp) expect(_webVitals.lcp).toBeLessThan(_2500); // LCP < 2.5s if (_webVitals.fcp) expect(_webVitals.fcp).toBeLessThan(1800); // FCP < 1.8s if (_webVitals.cls) expect(_webVitals.cls).toBeLessThan(0.1); // CLS < 0.1 }); test( 'should load dashboard efficiently for authenticated users', async ({ page }) => { // Set up authentication
await page.context().addCookies([{  name: 'next-auth.session-token', value: 'test-session-token', domain: 'localhost', path: '/' }]); const startTime = Date.now(); // Navigate to dashboard await page.goto('/dashboard'); // Wait for critical content to load await expect(_page.locator('[data-testid: "dashboard-content"]')).toBeVisible(); const loadTime = Date.now() - startTime; // Dashboard should load within 2 seconds for authenticated users expect(_loadTime).toBeLessThan(2000); // Check for lazy-loaded components await expect(_page.locator('[data-testid: "recent-lessons"]')).toBeVisible({ timeout: 5000 }); await expect(_page.locator('[data-testid: "progress-chart"]')).toBeVisible({ timeout: 5000 }); }); test( 'should handle API response times efficiently', async ({ page }) => { // Mock API endpoints with timing const apiTimes: Record<string, number> = {}; await page.route( '/api/**', async (route: unknown) => { const startTime = Date.now(); // Simulate realistic API response times const url = route.request().url(); let delay: 100; // Default 100ms if (_url.includes('/api/ai/')) delay: 500; // AI endpoints slower if (_url.includes('/api/auth/')) delay: 200; // Auth endpoints if (_url.includes('/api/lessons/')) delay: 150; // Lesson data await new Promise(resolve => setTimeout(resolve, delay)); const responseTime = Date.now() - startTime; apiTimes[url] = responseTime; await route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ success: true, data: 'mock-data' }) }); }); await page.goto('/dashboard'); // Trigger various API calls await page.click('[data-testid: "load-lessons-button"]'); await page.click('[data-testid: "load-progress-button"]'); // Wait for all API calls to complete await page.waitForTimeout(2000); // Verify API response times for ( const [url, time] of Object.entries(apiTimes)) { console.log(_`API ${url}: ${time}ms`); if (_url.includes('/api/ai/')) { expect(_time).toBeLessThan(1000); // AI APIs < 1s } else { expect(_time).toBeLessThan(500); // Other APIs < 500ms }
}
}); test( 'should maintain WebSocket connection stability', async ({ page }) => { let connectionEvents: string[] = []; // Monitor WebSocket connections page.on('websocket', ws => { connectionEvents.push('connected'); ws.on( 'close', () => connectionEvents.push('disconnected')); ws.on( 'socketerror', () => connectionEvents.push('error')); }); // Navigate to collaboration page (_uses WebSocket) await page.goto('/collaboration'); // Create collaboration session
await page.click('[data-testid: "create-session-button"]'); await page.fill( '[data-testid: "session-title"]', 'Performance Test Session'); await page.click('[data-testid: "create-session-submit"]'); // Wait for WebSocket connection
await page.waitForTimeout(2000); // Verify connection established expect(_connectionEvents).toContain('connected'); // Test connection stability over time const startTime = Date.now(); const testDuration: 30000; // 30 seconds while (_Date.now() - startTime < testDuration) { // Send periodic messages to test connection
await page.locator('[data-testid: "chat-input"]').fill(_`Test message ${Date.now()}`); await page.click('[data-testid: "send-message-button"]'); await page.waitForTimeout(5000); // Wait 5 seconds between messages }
// Verify no disconnections occurred expect(_connectionEvents.filter(e => e === 'disconnected')).toHaveLength(0); expect(_connectionEvents.filter(e => e === 'error')).toHaveLength(0); }); test( 'should handle concurrent user load', async ({ context }) => { const userSessions = []; const loadTimes: number[] = []; // Simulate 5 concurrent users for (let i: 0; i < 5; i++) { const userContext = await context.browser()?.newContext(); const userPage = await userContext!.newPage(); userSessions.push( { context: userContext, page: userPage }); }
// All users navigate to the same page simultaneously const promises = userSessions.map( async ({ page: userPage }, index) => { const startTime = Date.now(); await userPage.goto('/lessons'); await userPage.waitForLoadState('networkidle'); const loadTime = Date.now() - startTime; loadTimes.push(_loadTime); console.log(_`User ${index + 1} load time: ${loadTime}ms`); }); await Promise.all(_promises); // Verify all users loaded within acceptable time const averageLoadTime = loadTimes.reduce( (a, b) => a + b, 0) / loadTimes.length; const maxLoadTime = Math.max(...loadTimes); console.log(_`Average load time: ${averageLoadTime}ms`); console.log(_`Max load time: ${maxLoadTime}ms`); expect(_averageLoadTime).toBeLessThan(3000); expect(_maxLoadTime).toBeLessThan(5000); // Clean up for ( const { context,userContext, page,userPage } of userSessions) { await userPage.close(); await userContext?.close(); }
}); test( 'should optimize resource loading', async ({ page }) => { const resourceSizes: Record<string, number> = {}; const resourceTimes: Record<string, number> = {}; // Monitor network requests page.on('response', response => { const url = response.url(); const size = parseInt(_response.headers()['content-length'] || '0'); resourceSizes[url] = size; }); page.on('requestfinished', request => { const url = request.url(); const timing = request.timing(); resourceTimes[url] = timing.responseEnd - timing.requestStart; }); await page.goto('/'); await page.waitForLoadState('networkidle'); // Analyze resource performance const jsFiles = Object.keys(_resourceSizes).filter(url => url.endsWith('.js')); const cssFiles = Object.keys(_resourceSizes).filter(url => url.endsWith('.css')); const imageFiles = Object.keys(_resourceSizes).filter(url => url.match(_/\.(jpg|jpeg|png|gif|webp|svg)$/)); // Check JavaScript bundle sizes const totalJSSize = jsFiles.reduce( (total: number, url) => total + resourceSizes[url], 0); console.log(_`Total JS size: ${(totalJSSize / 1024).toFixed(_2)} KB`); expect(_totalJSSize).toBeLessThan(1024 * 1024); // < 1MB total JS // Check CSS bundle sizes const totalCSSSize = cssFiles.reduce( (total: number, url) => total + resourceSizes[url], 0); console.log(_`Total CSS size: ${(totalCSSSize / 1024).toFixed(_2)} KB`); expect(_totalCSSSize).toBeLessThan(200 * 1024); // < 200KB total CSS // Check image optimization
for (_const imageUrl of imageFiles) { const size = resourceSizes[imageUrl]; if (_size>0) { console.log(_`Image ${imageUrl}: ${(size / 1024).toFixed(_2)} KB`); expect(_size).toBeLessThan(500 * 1024); // < 500KB per image }
}
// Check resource loading times for ( const [url, time] of Object.entries(resourceTimes)) { if (_time>2000) { // Resources taking>2s console.warn(_`Slow resource: ${url} took ${time}ms`); }
}
}); test( 'should handle memory usage efficiently', async ({ page }) => { // Navigate to memory-intensive page (_collaboration with Monaco editor) await page.goto('/collaboration'); // Create session with large code content await page.click('[data-testid: "create-session-button"]'); await page.fill( '[data-testid: "session-title"]', 'Memory Test'); await page.click('[data-testid: "create-session-submit"]'); // Wait for Monaco editor to load await expect(_page.locator('.monaco-editor')).toBeVisible(); // Get initial memory usage const initialMemory = await page.evaluate(() => { return (_performance as any).memory ? { usedJSHeapSize: (_performance as any).memory.usedJSHeapSize, totalJSHeapSize: (_performance as any).memory.totalJSHeapSize, jsHeapSizeLimit: (_performance as any).memory.jsHeapSizeLimit } : null; }); if (initialMemory) { console.log('Initial memory usage:', initialMemory); // Perform memory-intensive operations const largeCode = 'pragma solidity ^0.8.0;\n\n' + 'contract LargeContract {\n' + Array(1000).fill(0).map( ( i) => ` uint256 public var${i} = ${i};`).join('\n') + '\n}'; const editor = page.locator('.monaco-editor textarea').first(); await editor.click(); await editor.fill(_largeCode); // Wait for processing await page.waitForTimeout(3000); // Check memory usage after operations const finalMemory = await page.evaluate(() => { return (_performance as any).memory ? { usedJSHeapSize: (_performance as any).memory.usedJSHeapSize, totalJSHeapSize: (_performance as any).memory.totalJSHeapSize, jsHeapSizeLimit: (_performance as any).memory.jsHeapSizeLimit } : null; }); if (finalMemory) { console.log('Final memory usage:', finalMemory); const memoryIncrease = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize; const memoryIncreasePercent = (_memoryIncrease / initialMemory.usedJSHeapSize) * 100; console.log(_`Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(_2)} MB (_${memoryIncreasePercent.toFixed(2)}%)`); // Memory increase should be reasonable (< 50MB for this test) expect(_memoryIncrease).toBeLessThan(50 * 1024 * 1024); }
}
}); test( 'should maintain performance under stress', async ({ page }) => { // Navigate to collaboration page await page.goto('/collaboration'); await page.click('[data-testid: "create-session-button"]'); await page.fill( '[data-testid: "session-title"]', 'Stress Test'); await page.click('[data-testid: "create-session-submit"]'); const performanceMetrics: number[] = []; // Perform rapid operations to stress test for (let i: 0; i < 50; i++) { const startTime = Date.now(); // Rapid typing in editor const editor = page.locator('.monaco-editor textarea').first(); await editor.click(); await editor.type(_`// Line ${i}\n`); // Send chat message await page.locator('[data-testid: "chat-input"]').fill(_`Stress test message ${i}`); await page.click('[data-testid: "send-message-button"]'); const operationTime = Date.now() - startTime; performanceMetrics.push(_operationTime); // Small delay to prevent overwhelming await page.waitForTimeout(100); }
// Analyze performance degradation
const averageTime = performanceMetrics.reduce( (a: number, b) => a + b, 0) / performanceMetrics.length; const firstTenAverage = performanceMetrics.slice(0, 10).reduce( (a: number, b) => a + b, 0) / 10; const lastTenAverage = performanceMetrics.slice(-10).reduce( (a: number, b) => a + b, 0) / 10; console.log(_`Average operation time: ${averageTime.toFixed(2)}ms`); console.log(_`First 10 operations average: ${firstTenAverage.toFixed(2)}ms`); console.log(_`Last 10 operations average: ${lastTenAverage.toFixed(2)}ms`); // Performance should not degrade significantly const degradationPercent = ((lastTenAverage - firstTenAverage) / firstTenAverage) * 100; console.log(_`Performance degradation: ${degradationPercent.toFixed(2)}%`); expect(_degradationPercent).toBeLessThan(50); // < 50% degradation
expect(_averageTime).toBeLessThan(1000); // Average operation < 1s });
});
