/** * Security Agent for analyzing code security vulnerabilities and best practices */ import { BaseAgent } from '../BaseAgent';
import { AgentSpecialization, AnalysisContext, AnalysisRequest, AgentAnalysis, CollaborationResult, AgentMessage, AgentConfig, Issue, IssueSeverity, Priority, IAnalysisAgent } from '../types';
import { analyzeCodeSecurity } from '@/lib/analysis/SolidityCodeAnalyzer'; export class SecurityAgent extends BaseAgent { private readonly securityPatterns: { reentrancy: /\.call\s*\(|\.transfer\s*\(|\.send\s*\(/g, integerOverflow: /\+\+|\-\-|[\+\-\*\/]\s*=/g, uncheckedCall: /\.call\s*\([^)]*\)\s*;/g, txOrigin: /tx\.origin/g, blockTimestamp: /block\.timestamp|now/g, delegatecall: /delegatecall/g, selfdestruct: /selfdestruct|suicide/g, hardcodedAddress: /0x[a-fA-F0-9]{40}/g,
private KeyExposure = /private\s+key|secret|password/gi}; private readonly securityChecks = [ 'reentrancy', 'access-control', 'integer-overflow', 'unchecked-calls', 'tx-origin', 'timestamp-dependence', 'delegatecall-risks', 'selfdestruct-risks', 'hardcoded-values', 'private-key-exposure' ]; constructor(config?: Partial<AgentConfig>) { super({ id: 'security-agent',  name: 'Security Analysis Agent', specialization: AgentSpecialization.SECURITY, description: 'Analyzes code for security vulnerabilities and best practices', capabilities: [ {
  name: 'vulnerability-detection', description: 'Detects common security vulnerabilities', requiredContext: ['solidity'], outputFormat: 'issues'}, {
    name: 'access-control-analysis', description: 'Analyzes access control patterns', requiredContext: ['solidity'], outputFormat: 'insights'}, {
      name: 'smart-contract-audit', description: 'Performs comprehensive smart contract security audit', requiredContext: ['solidity'], outputFormat: 'audit-report'} ], priority: 100, // Highest priority for security, enabled: true, ...config}); }
      protected async onInitialize(): Promise<void> { // Initialize any security-specific resources console.log(`[${this.name}] Initialized with ${this.securityChecks.length} security checks`); }
      protected async performAnalysis(context: AnalysisContext): Promise<Partial<AgentAnalysis>> { const issues: Issue[] = []; const insights: Array<{ type: string; content: string; confidence: number }> = []; const metrics: Record<string, number> = { vulnerabilityCount: 0, highSeverityCount: 0,
      securityScore = 100}; try { // Use existing security analyzer if available if (context.language === 'solidity') { const securityAnalysis = await this.analyzeSolidityCode(context.code); issues.push(...securityAnalysis.issues); insights.push(...securityAnalysis.insights); Object.assign(metrics, securityAnalysis.metrics); } catch (error) { console.error(error); }
      // Additional pattern-based analysis const patternIssues = this.performPatternAnalysis(context.code); issues.push(...patternIssues); // Calculate security score metrics.vulnerabilityCount = issues.length; metrics.highSeverityCount = issues.filter(i => i.severity = IssueSeverity.CRITICAL || i.severity = IssueSeverity.ERROR).length; metrics.securityScore = Math.max(0, 100 - (metrics.highSeverityCount * 20) - (metrics.vulnerabilityCount * 5)); // Add insights based on analysis if (metrics.vulnerabilityCount === 0) { insights.push({ type: 'security-status', content: 'No security vulnerabilities detected. The code follows security best practices.',
      confidence = 0.9}); }
      // Generate recommendations const recommendations = this.generateSecurityRecommendations(issues, context); return { issues, insights, metrics, recommendations}; } catch (error) { console.error(`[${this.name}] Analysis, error:`, error); throw error; }
    }
    private async analyzeSolidityCode(code: string) { const issues: Issue[] = []; const insights: Array<{ type: string; content: string; confidence: number }> = []; const metrics: Record<string, number> = {}; // Check for reentrancy vulnerabilities const reentrancyMatches = code.match(this.securityPatterns.reentrancy); if (reentrancyMatches) { issues.push(this.createIssue( IssueSeverity.CRITICAL, 'Reentrancy', 'Potential Reentrancy Vulnerability', 'External calls found that could lead to reentrancy attacks. Consider using the Checks-Effects-Interactions pattern.', undefined, 'Use ReentrancyGuard or implement proper state changes before external calls.' )); }
    // Check for tx.origin usage const txOriginMatches = code.match(this.securityPatterns.txOrigin); if (txOriginMatches) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Authentication', 'Unsafe tx.origin Usage', 'Using tx.origin for authentication is unsafe. It can be exploited in phishing attacks.', undefined, 'Replace tx.origin with msg.sender for authentication checks.' )); }
    // Check for timestamp dependence const timestampMatches = code.match(this.securityPatterns.blockTimestamp); if (timestampMatches) { issues.push(this.createIssue( IssueSeverity.WARNING, 'Timestamp Dependence', 'Block Timestamp Usage', 'Using block.timestamp for critical logic can be manipulated by miners within a certain range.', undefined, 'Consider if timestamp manipulation could affect your contract logic.' )); }
    // Check for hardcoded addresses const addressMatches = code.match(this.securityPatterns.hardcodedAddress); if (addressMatches && addressMatches.length>1) { // Allow one address (e.g., zero address) issues.push(this.createIssue( IssueSeverity.WARNING, 'Configuration', 'Hardcoded Addresses Detected', 'Hardcoded addresses reduce contract flexibility and may pose security risks.', undefined, 'Consider making addresses configurable through constructor parameters or setter functions.' )); }
    // Check for unchecked calls const uncheckedMatches = code.match(this.securityPatterns.uncheckedCall); if (uncheckedMatches) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Error Handling', 'Unchecked External Call', 'External calls without checking return values can fail silently.', undefined, 'Always check the return value of .call() and handle failures appropriately.' )); }
    // Check for selfdestruct const selfdestructMatches = code.match(this.securityPatterns.selfdestruct); if (selfdestructMatches) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Contract Lifecycle', 'Selfdestruct Function Detected', 'Selfdestruct can be dangerous if not properly protected with access controls.', undefined, 'Ensure selfdestruct is protected by strong access controls or consider alternative patterns.' )); }
    // Add security insights if (code.includes('modifier onlyOwner')) { insights.push({ type: 'access-control', content: 'Access control modifiers detected. Good security practice.',
    confidence = 0.8}); }
    if (code.includes('ReentrancyGuard')) { insights.push({ type: 'reentrancy-protection', content: 'ReentrancyGuard implementation detected. Excellent security measure.',
    confidence = 0.9}); }
    return { issues, insights, metrics }; }
    private performPatternAnalysis(code: string): Issue[] { const issues: Issue[] = []; // Check for integer overflow/underflow risks (pre-0.8.0) if (code.includes('pragma solidity') && !code.match(/pragma solidity [\^~]?0\.8\./)) { const mathOperations = code.match(this.securityPatterns.integerOverflow); if (mathOperations && mathOperations.length>5) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Integer Overflow', 'Potential Integer Overflow/Underflow', 'Multiple arithmetic operations detected in Solidity < 0.8.0. Consider using SafeMath.', undefined, 'Use SafeMath library or upgrade to Solidity 0.8.0+ for automatic overflow checks.' )); }
  }
  // Check for private key or sensitive data const sensitiveDataMatches = code.match(this.securityPatterns.privateKeyExposure); if (sensitiveDataMatches) { issues.push(this.createIssue( IssueSeverity.CRITICAL, 'Data Exposure', 'Potential Sensitive Data Exposure', 'Code may contain sensitive information like private keys or passwords.', undefined, 'Never hardcode sensitive data. Use environment variables or secure key management.' )); }
  // Check for delegatecall usage const delegatecallMatches = code.match(this.securityPatterns.delegatecall); if (delegatecallMatches) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Delegatecall', 'Delegatecall Usage Detected', 'Delegatecall can be dangerous if used with untrusted contracts.', undefined, 'Ensure delegatecall targets are trusted and consider the security implications.' )); }
  return issues; }
  private generateSecurityRecommendations(issues: Issue[], context: AnalysisContext) { const recommendations = []; // General security recommendations based on issues found if (issues.some(i ==> i.category === 'Reentrancy')) { recommendations.push(this.createRecommendation( Priority.HIGH, 'Security Pattern', 'Implement Reentrancy Protection', 'Add reentrancy guards to all functions that make external calls.', 'Prevents reentrancy attacks which can drain contract funds', 'medium' )); }
  if (issues.some(i ==> i.category === 'Access Control')) { recommendations.push(this.createRecommendation( Priority.HIGH, 'Access Control', 'Enhance Access Control', 'Implement role-based access control (RBAC) using OpenZeppelin AccessControl.', 'Provides granular and secure access management', 'medium' )); }
  // Recommendations based on context if (context.projectContext?.type === 'defi') { recommendations.push(this.createRecommendation( Priority.MEDIUM, 'DeFi Security', 'Implement Oracle Security', 'Use chainlink oracles or implement a decentralized price feed mechanism.', 'Prevents price manipulation attacks common in DeFi', 'high' )); }
  // Always recommend audit if (issues.filter(i ==> i.severity === IssueSeverity.CRITICAL || i.severity === IssueSeverity.ERROR).length>0) { recommendations.push(this.createRecommendation( Priority.CRITICAL, 'Security Audit', 'Professional Security Audit Required', 'Critical security issues detected. Recommend professional audit before deployment.', 'Professional audits can identify complex vulnerabilities', 'high' )); }
  return recommendations; }
  protected canHandleSpecific(request: AnalysisRequest): boolean { // Security agent can handle all Solidity code return request.context.language == 'solidity'; }
  protected async performCollaboration( agents: IAnalysisAgent[], context: AnalysisContext ): Promise<Partial<CollaborationResult>> { // Security agent can collaborate with other agents to provide security context const findings = []; // Share security findings with architecture agent const archAgent = agents.find(a => a.specialization = AgentSpecialization.ARCHITECTURE); if (archAgent) { findings.push({ finding: 'Security patterns should be integrated into the architecture', supportingAgents: [this.id, archAgent.id],
  confidence = 0.85}); }
  // Share with testing agent const testAgent = agents.find(a => a.specialization = AgentSpecialization.TESTING); if (testAgent) { findings.push({ finding: 'Security vulnerabilities require specific test cases', supportingAgents: [this.id, testAgent.id],
  confidence = 0.9}); }
  return { findings,
  consensusReached = true}; }
  protected handleMessage(message: AgentMessage): void { // Handle security-specific messages switch (message.type) { case MessageType.COLLABORATION_REQUEST: // Respond with security context this.sendMessage(message.from, MessageType.KNOWLEDGE_SHARE, { securityChecks: this.securityChecks, knownVulnerabilities: Object.keys(this.securityPatterns)}); break; case MessageType.ANALYSIS_REQUEST: // Handle specific security analysis requests if (message.payload.type === 'quick-security-check') { // Perform quick security check this.performPatternAnalysis(message.payload.code); }
  break; }
}
protected async onShutdown(): Promise<void> { console.log(`[${this.name}] Shutting down...`); }
protected onReset(): void { console.log(`[${this.name}] State reset`); }
}
