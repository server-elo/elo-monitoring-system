/** * Testing Agent for analyzing test coverage, quality, and suggesting improvements */ import { BaseAgent } from '../BaseAgent';
import { AgentSpecialization, AnalysisContext, AnalysisRequest, AgentAnalysis, CollaborationResult, AgentMessage, AgentConfig, Issue, IssueSeverity, Priority, IAnalysisAgent, MessageType } from '../types'; interface TestPattern {
  name: string;
  pattern: RegExp;
  category: 'unit' | 'integration' | 'e2e' | 'security';
  quality: 'good' | 'bad' | 'missing';
} interface TestMetrics {
  estimatedCoverage: number;
  testTypes: string[];
  missingTestCategories: string[];
  testQualityScore: number;
  edgeCasesCovered: number;
} export class TestingAgent extends BaseAgent { private readonly testPatterns: TestPattern[] = [ // Good test patterns {
  name: 'Unit Test', pattern: /describe\s*\(['"].*['"],|it\s*\(['"]should.*['"],|test\s*\(['"].*['"],/g, category: 'unit', quality: 'good'}, {
    name: 'Assertion', pattern: /expect\s*\(|assert\s*\.|should\s*\./g, category: 'unit', quality: 'good'}, {
      name: 'Edge Case Test', pattern: /it\s*\(['"].*(?:edge|boundary|limit|overflow|underflow).*['"],/gi, category: 'unit', quality: 'good'}, {
        name: 'Security Test', pattern: /it\s*\(['"].*(?:revert|fail|unauthorized|attack|exploit).*['"],/gi, category: 'security', quality: 'good'}, {
          name: 'Gas Test', pattern: /gas(?:Used|Cost|Estimate)|\.estimateGas\(/gi, category: 'unit', quality: 'good'}, // Bad patterns {
            name: 'Console Log in Test', pattern: /console\.(log|error|warn)\s*\(/g, category: 'unit', quality: 'bad'}, {
              name: 'Commented Test', pattern: /\/\/\s*(it|test|describe)\s*\(/g, category: 'unit', quality: 'bad'}, {
                name: 'Skip Test', pattern: /\.(skip|only)\s*\(/g, category: 'unit', quality: 'bad'} ]; private readonly solidityTestRequirements = [ 'Constructor tests', 'Access control tests', 'State change tests', 'Event emission tests', 'Revert condition tests', 'Edge case tests', 'Gas optimization tests', 'Integration tests', 'Reentrancy tests', 'Overflow/Underflow tests' ]; private readonly criticalFunctions = [ 'transfer', 'withdraw', 'deposit', 'mint', 'burn', 'approve', 'stake', 'unstake', 'claim', 'execute' ]; constructor(config?: Partial<AgentConfig>) { super({ id: 'testing-agent',  name: 'Testing Analysis Agent', specialization: AgentSpecialization.TESTING, description: 'Analyzes test coverage, quality, and suggests test improvements', capabilities: [ {
                  name: 'coverage-analysis', description: 'Analyzes test coverage and identifies gaps', requiredContext: ['solidity', 'javascript', 'typescript'], outputFormat: 'coverage-report'}, {
                    name: 'test-quality', description: 'Evaluates test quality and completeness', requiredContext: ['solidity', 'javascript', 'typescript'], outputFormat: 'quality-metrics'}, {
                      name: 'test-generation', description: 'Suggests missing tests and test scenarios', requiredContext: ['solidity'], outputFormat: 'test-suggestions'} ], priority: 80, enabled: true, ...config}); }
                      protected async onInitialize(): Promise<void> { console.log(`[${this.name}] Initialized with ${this.testPatterns.length} test patterns`); }
                      protected async performAnalysis(context: AnalysisContext): Promise<Partial<AgentAnalysis>> { const issues: Issue[] = []; const insights: Array<{ type: string; content: string; confidence: number }> = []; const metrics: Record<string, number> = {}; try { // Check if this is test code or production code const isTestFile = this.isTestCode(context.code, context.fileName); if (isTestFile) { // Analyze test code quality const testQuality = this.analyzeTestQuality(context.code); issues.push(...testQuality.issues); insights.push(...testQuality.insights); Object.assign(metrics, testQuality.metrics); } else { // Analyze testability and suggest tests for production code const testability = this.analyzeTestability(context.code, context.language); issues.push(...testability.issues); insights.push(...testability.insights); Object.assign(metrics, testability.metrics); }
                      // Generate test recommendations const recommendations = this.generateTestRecommendations( issues, metrics, context, isTestFile ); return { issues, insights, metrics, recommendations}; } catch (error) { console.error(`[${this.name}] Analysis, error:`, error); throw error; }
                    }
                    private isTestCode(code: string, fileName?: string): boolean { return ( (fileName && (fileName.includes('.test.') || fileName.includes('.spec.'))) || code.includes('describe(') || code.includes('it(') || code.includes('test(') ); }
                    private analyzeTestQuality(code: string) { const issues: Issue[] = []; const insights: Array<{ type: string; content: string; confidence: number }> = []; const metrics: Record<string, number> = { testCount: 0, assertionCount: 0, testQualityScore: 100,
                    badPatternsCount = 0}; // Count tests and assertions const tests = code.match(/it\s*\(['"]|test\s*\(['"]/g) || []; const assertions = code.match(/expect\s*\(|assert\.|should\./g) || []; metrics.testCount = tests.length; metrics.assertionCount = assertions.length; // Check test patterns for (const pattern of this.testPatterns) { const matches = code.match(pattern.pattern); if (matches) { if (pattern.quality === 'bad') { metrics.badPatternsCount += matches.length; issues.push(this.createIssue( IssueSeverity.WARNING, 'Test Quality', `Bad Test, Pattern: ${pattern.name}`, `Found ${matches.length} instance(s) of ${pattern.name}`, undefined, 'Remove or fix the identified pattern' )); } else if (pattern.quality === 'good' && pattern.category === 'security') { insights.push({ type: 'test-coverage', content: `Security tests detected (${pattern.name})`,
                    confidence = 0.9}); }
                  }
                }
                // Check assertion density const assertionDensity = metrics.testCount>0 ? metrics.assertionCount / metrics.testCount : 0; if (assertionDensity < 1 && metrics.testCount>0) { issues.push(this.createIssue( IssueSeverity.WARNING, 'Test Quality', 'Low Assertion Density', `Average ${assertionDensity.toFixed(1)} assertions per test. Tests may not be thorough.`, undefined, 'Add more assertions to verify expected behavior' )); }
                // Check for test descriptions const poorDescriptions = code.match(/it\s*\(['"]test['"]/gi) || []; if (poorDescriptions.length>0) { issues.push(this.createIssue( IssueSeverity.INFO, 'Test Quality', 'Generic Test Descriptions', 'Found tests with generic descriptions. Use descriptive test names.', undefined, 'Use "should [expected behavior] when [condition]" format' )); }
                // Calculate quality score metrics.testQualityScore = Math.max( 0, 100 - (metrics.badPatternsCount * 10) - (poorDescriptions.length * 5) ); // Add insights if (metrics.testCount>10) { insights.push({ type: 'test-coverage', content: `Comprehensive test suite with ${metrics.testCount} tests`,
                confidence = 0.8}); }
                return { issues, insights, metrics }; }
                private analyzeTestability(code: string, language: string) { const issues: Issue[] = []; const insights: Array<{ type: string; content: string; confidence: number }> = []; const metrics: TestMetrics = { estimatedCoverage: 0, testTypes: [], missingTestCategories: [], testQualityScore: 0,
                edgeCasesCovered = 0}; if (language === 'solidity') { // Analyze Solidity contract for test requirements const functions = this.extractFunctions(code); const publicFunctions = functions.filter(f => f.includes('public') || f.includes('external') ); // Check for critical functions that need testing const criticalFunctionsFound = this.criticalFunctions.filter(fn => code.includes(`function ${fn}`) ); if (criticalFunctionsFound.length>0) { issues.push(this.createIssue( IssueSeverity.ERROR, 'Test Coverage', 'Critical Functions Need Testing', `Found ${criticalFunctionsFound.length} critical functions that require comprehensive, testing: ${criticalFunctionsFound.join(', ')}`, undefined, 'Write thorough tests including edge cases and failure scenarios' )); }
                // Check for modifiers that need testing const modifiers = (code.match(/modifier\s+\w+/g) || []).map(m => m.split(' ')[1]); if (modifiers.length>0) { insights.push({ type: 'test-requirement', content: `${modifiers.length} modifiers need access control testing`,
                confidence = 0.85}); metrics.missingTestCategories.push('Access Control Tests'); }
                // Check for events that need testing const events = (code.match(/event\s+\w+/g) || []).length; if (events>0) { metrics.missingTestCategories.push('Event Emission Tests'); }
                // Check for payable functions if (code.includes('payable')) { metrics.missingTestCategories.push('Payment Tests'); metrics.missingTestCategories.push('Reentrancy Tests'); }
                // Estimate coverage based on function count const functionsNeedingTests = publicFunctions.length + modifiers.length; metrics.estimatedCoverage = functionsNeedingTests>0 ? 0 : 100; // 0% if no tests exist // Check for complex logic needing edge case tests const complexConditions = (code.match(/if\s*\(.*&&.*\)|if\s*\(.*\|\|.*\)/g) || []).length; if (complexConditions>3) { issues.push(this.createIssue( IssueSeverity.WARNING, 'Test Coverage', 'Complex Logic Requires Edge Case Testing', `Found ${complexConditions} complex conditions that need edge case coverage`, undefined, 'Test all condition combinations and boundary values' )); }
                // Add requirement insights const missingRequirements = this.solidityTestRequirements.filter(req => { const, keyword: req.toLowerCase().replace(' tests', ''); return !code.toLowerCase().includes(keyword); }); if (missingRequirements.length>0) { metrics.missingTestCategories.push(...missingRequirements); }
              }
              // General testability checks const longFunctions = this.identifyLongFunctions(code); if (longFunctions.length>0) { issues.push(this.createIssue( IssueSeverity.INFO, 'Testability', 'Long Functions Harder to Test', `Found ${longFunctions.length} long functions that may be difficult to test comprehensively`, undefined, 'Break down into smaller, testable units' )); }
              // Calculate test quality score metrics.testQualityScore = Math.max( 0, 100 - (metrics.missingTestCategories.length * 10) ); return { issues, insights, metrics }; }
              private extractFunctions(code: string): string[] { const functionPattern = /function\s+\w+[^{]*{/g; return (code.match(functionPattern) || []); }
              private identifyLongFunctions(code: string): string[] { const functions = code.match(/function\s+\w+[^{]*{[^}]*}/g) || []; return functions.filter(f => f.split('\n').length>30); }
              private generateTestRecommendations( issues: Issue[], metrics: Record<string, number>, context: AnalysisContext, isTestFile: boolean
            ) { const recommendations = []; if (isTestFile) { // Recommendations for test files if (metrics.testQualityScore < 70) { recommendations.push(this.createRecommendation( Priority.HIGH, 'Test Quality', 'Improve Test Quality', 'Fix identified test quality issues and follow best practices', 'Higher quality tests catch more bugs', 'low' )); }
            if (metrics.assertionCount / metrics.testCount < 2) { recommendations.push(this.createRecommendation( Priority.MEDIUM, 'Test Completeness', 'Add More Assertions', 'Increase assertion density to thoroughly verify behavior', 'More assertions ensure comprehensive validation', 'low' )); }
          } else { // Recommendations for production code if (context.language === 'solidity') { recommendations.push(this.createRecommendation( Priority.CRITICAL, 'Test Coverage', 'Create Comprehensive Test Suite', 'Write tests covering all public functions, modifiers, and events', 'Prevents costly bugs in smart contracts', 'high' )); if ((metrics as TestMetrics).missingTestCategories?.includes('Security Tests')) { recommendations.push(this.createRecommendation( Priority.HIGH, 'Security Testing', 'Add Security-Focused Tests', 'Include tests for access control, reentrancy, and overflow scenarios', 'Critical for smart contract security', 'medium' )); }
          recommendations.push(this.createRecommendation( Priority.MEDIUM, 'Gas Testing', 'Implement Gas Usage Tests', 'Add tests that measure and optimize gas consumption', 'Helps users save on transaction costs', 'medium' )); }
          // General testing recommendations const criticalIssues = issues.filter(i => i.severity = IssueSeverity.CRITICAL); if (criticalIssues.length>0) { recommendations.push(this.createRecommendation( Priority.CRITICAL, 'Critical Testing', 'Address Critical Test Gaps', 'Write tests for all critical functions identified', 'Prevents catastrophic failures', 'high' )); }
          if ((metrics as TestMetrics).missingTestCategories?.length>5) { recommendations.push(this.createRecommendation( Priority.HIGH, 'Test Strategy', 'Develop Comprehensive Test Strategy', 'Create a testing plan covering unit, integration, and edge cases', 'Systematic testing improves reliability', 'medium' )); }
        }
        // Context-specific recommendations if (context.projectContext?.type === 'defi') { recommendations.push(this.createRecommendation( Priority.HIGH, 'DeFi Testing', 'Add DeFi-Specific Tests', 'Include tests for slippage, front-running, and oracle manipulation', 'DeFi protocols need specialized security tests', 'high' )); }
        return recommendations; }
        protected canHandleSpecific(request: AnalysisRequest): boolean { // Testing agent can analyze all supported languages const supportedLanguages = ['solidity', 'javascript', 'typescript']; return supportedLanguages.includes(request.context.language); }
        protected async performCollaboration( agents: IAnalysisAgent[], context: AnalysisContext ): Promise<Partial<CollaborationResult>> { const findings = []; // Collaborate with security agent const securityAgent = agents.find(a => a.specialization = AgentSpecialization.SECURITY); if (securityAgent) { findings.push({ finding: 'Security vulnerabilities must have corresponding test cases', supportingAgents: [this.id, securityAgent.id],
        confidence = 0.95}); }
        // Collaborate with performance agent const perfAgent = agents.find(a => a.specialization = AgentSpecialization.PERFORMANCE); if (perfAgent) { findings.push({ finding: 'Performance optimizations should be validated with tests', supportingAgents: [this.id, perfAgent.id],
        confidence = 0.85}); }
        // Collaborate with architecture agent const archAgent = agents.find(a => a.specialization = AgentSpecialization.ARCHITECTURE); if (archAgent) { findings.push({ finding: 'Each architectural component needs isolated unit tests', supportingAgents: [this.id, archAgent.id],
        confidence = 0.9}); }
        return { findings,
        consensusReached = true}; }
        protected handleMessage(message: AgentMessage): void { switch (message.type) { case MessageType.COLLABORATION_REQUEST: // Share testing insights this.sendMessage(message.from, MessageType.KNOWLEDGE_SHARE, { testRequirements: this.solidityTestRequirements,
        criticalFunctions = this.criticalFunctions}); break; case MessageType.ANALYSIS_REQUEST: if (message.payload.type === 'test-suggestion') { // Generate test suggestions for specific code const suggestions = this.generateTestSuggestions(message.payload.code); this.sendMessage(message.from, MessageType.ANALYSIS_RESULT, { suggestions }); }
        break; case MessageType.KNOWLEDGE_SHARE: // Receive insights from 'other' agents if (message.payload.vulnerabilities) { // Update test requirements based on security findings console.log(`[${this.name}] Received security vulnerabilities to test`); }
        break; }
      }
      private generateTestSuggestions(code: string): string[] { const suggestions = []; // Extract function names const functions = code.match(/function\s+(\w+)/g) || []; for (const func of functions) { const funcName = func.replace('function ', ''); suggestions.push(`Test ${funcName} with valid inputs`); suggestions.push(`Test ${funcName} with invalid inputs`); suggestions.push(`Test ${funcName} access control`); }
      return suggestions; }
      protected async onShutdown(): Promise<void> { console.log(`[${this.name}] Shutting down...`); }
      protected onReset(): void { console.log(`[${this.name}] State reset`); }
    }
    