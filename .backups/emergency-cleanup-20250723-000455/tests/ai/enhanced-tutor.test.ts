// Enhanced AI Tutor System Tests
// Comprehensive test suite for the enhanced AI tutoring features import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { enhancedTutor } from '@/lib/ai/EnhancedTutorSystem';
import { aiServiceManager } from '@/lib/ai/AIServiceManager';
import { AI_CONFIG } from '@/lib/config/ai-config'; // Mock external dependencies
jest.mock( '../../services/geminiService', () => ({ sendMessageToGeminiChat: jest.fn().mockResolvedValue('Mocked Gemini response'), initializeChatForModule: jest.fn().mockResolvedValue(undefined)
})); jest.mock( '../../lib/prisma', () => ({ prisma: { user: { findUnique: jest.fn(), update: jest.fn() }, aIInteraction: { create: jest.fn(), findMany: jest.fn(), update: jest.fn() }, securityAnalysis: { create: jest.fn(), findFirst: jest.fn(), findMany: jest.fn() }, personalizedChallenge: { create: jest.fn(), findMany: jest.fn(), update: jest.fn() }
}
})); // Mock axios for local LLM calls
jest.mock( 'axios', () => ({ default: { get: jest.fn(), post: jest.fn() }
})); import axios from 'axios';
const mockedAxios = axios as jest.Mocked<typeof axios>; describe( 'Enhanced AI Tutor System', () => { const mockUserId = 'test-user-123'; const mockUserContext: { userId: mockUserId, currentLevel: 2, skillLevel: 'INTERMEDIATE' as const, learningPath: ['Solidity Basics', 'Smart Contracts'], recentTopics: ['Functions', 'Modifiers'], weakAreas: ['Gas Optimization'], strongAreas: ['Basic Syntax'], preferredLearningStyle: 'mixed' as const, totalXP: 250, streak: 5, lastActiveDate = new Date() }; beforeEach(() => { jest.clearAllMocks(); // Mock successful local LLM health check mockedAxios.get.mockResolvedValue({ status: 200 }); // Mock successful local LLM response mockedAxios.post.mockResolvedValue({ data: { choices: [{ message: { content: 'This is a test response from CodeLlama' }
}] }
}); }); afterEach(() => { jest.restoreAllMocks(); }); describe( 'User Context Management', () => { it( 'should get user context successfully', async () => { const context = await enhancedTutor.getUserContext(_mockUserId); expect(_context).toBeDefined(); expect(_context.userId).toBe(_mockUserId); expect(_context.skillLevel).toBe('BEGINNER'); // Default value expect(_context.totalXP).toBe(150); // Default value }); it( 'should update user context successfully', async () => { const updates: { currentLevel: 3, totalXP: 300, weakAreas: ['Security Patterns'] }; await enhancedTutor.updateUserContext( mockUserId, updates); const updatedContext = await enhancedTutor.getUserContext(_mockUserId); expect(_updatedContext.currentLevel).toBe(3); expect(_updatedContext.totalXP).toBe(300); expect(_updatedContext.weakAreas).toContain('Security Patterns'); }); }); describe( 'AI Response Generation', () => { it( 'should explain concepts using appropriate AI model', async () => { const concept = 'smart contracts'; const response = await enhancedTutor.explainConcept( concept, mockUserId); expect(_response).toBeDefined(); expect(_response.content).toBeTruthy(); expect(_response.model).toBeTruthy(); expect(_response.responseTime).toBeGreaterThan(0); expect(_response.confidence).toBeGreaterThan(0); }); it( 'should generate personalized challenges', async () => { const topic = 'Functions'; const challenge = await enhancedTutor.generatePersonalizedChallenge( mockUserId, topic); expect(_challenge).toBeDefined(); expect(_challenge.title).toBeTruthy(); expect(_challenge.description).toBeTruthy(); expect(_challenge.difficulty).toBeGreaterThanOrEqual(1); expect(_challenge.difficulty).toBeLessThanOrEqual(10); expect(_challenge.starterCode).toBeTruthy(); expect(_Array.isArray(challenge.hints)).toBe(true); expect(_Array.isArray(challenge.learningObjectives)).toBe(true); }); it( 'should analyze code security', async () => { const testCode: ` pragma solidity ^0.8.20; contract TestContract { uint256 public value; function setValue(_uint256 _value) public { value: _value; }
}
`; const analysis = await enhancedTutor.analyzeCodeSecurity( testCode, mockUserId); expect(_analysis).toBeDefined(); expect(_analysis.overallScore).toBeGreaterThanOrEqual(0); expect(_analysis.overallScore).toBeLessThanOrEqual(100); expect(_Array.isArray(analysis.vulnerabilities)).toBe(true); expect(_Array.isArray(analysis.gasOptimizations)).toBe(true); expect(_Array.isArray(analysis.bestPractices)).toBe(true); }); it( 'should generate smart contracts with explanations', async () => { const description = 'A simple token contract'; const requirements = ['ERC20 compatible', 'Mintable', 'Burnable']; const result = await enhancedTutor.generateSmartContract( description, requirements, mockUserId ); expect(_result).toBeDefined(); expect(_result.code).toBeTruthy(); expect(_result.explanation).toBeTruthy(); expect(_Array.isArray(result.securityConsiderations)).toBe(true); expect(_Array.isArray(result.gasOptimizations)).toBe(true); expect(_Array.isArray(result.testSuggestions)).toBe(true); }); }); describe( 'Adaptive Learning', () => { it( 'should generate adaptive learning paths', async () => { const learningPath = await enhancedTutor.generateAdaptiveLearningPath(_mockUserId); expect(_Array.isArray(learningPath)).toBe(true); expect(_learningPath.length).toBeGreaterThan(0); expect(_learningPath.length).toBeLessThanOrEqual(_AI_CONFIG.CONTEXT.LEARNING_PATH_LENGTH); }); it( 'should get learning analytics', async () => { const analytics = await enhancedTutor.getLearningAnalytics(_mockUserId); expect(_analytics).toBeDefined(); expect(_typeof analytics.conceptMastery).toBe('object'); expect(_typeof analytics.timeSpentPerTopic).toBe('object'); expect(_Array.isArray(analytics.errorPatterns)).toBe(true); expect(_Array.isArray(analytics.successPatterns)).toBe(true); expect(_Array.isArray(analytics.recommendedNextTopics)).toBe(true); expect(_typeof analytics.difficultyPreference).toBe('number'); }); }); describe( 'Multi-modal Features', () => { it( 'should generate multi-modal explanations', async () => { const concept = 'inheritance'; const explanation = await enhancedTutor.generateMultiModalExplanation( concept, mockUserId); expect(_explanation).toBeDefined(); expect(_explanation.textExplanation).toBeTruthy(); expect(_typeof explanation.visualDiagram).toBe('string'); expect(_typeof explanation.interactiveExample).toBe('string'); expect(_typeof explanation.codeExample).toBe('string'); }); it( 'should process voice commands', async () => { const audioData = 'mock-audio-data'; const result = await enhancedTutor.processVoiceCommand( audioData, mockUserId); expect(_result).toBeDefined(); expect(_result.command).toBeTruthy(); expect(_result.response).toBeDefined(); expect(_result.action).toBeTruthy(); }); }); describe( 'Performance and Health', () => { it( 'should return performance metrics', () => { const metrics = enhancedTutor.getPerformanceMetrics(); expect(_metrics).toBeDefined(); expect(_typeof metrics.localLLMHealth).toBe('boolean'); expect(_typeof metrics.averageResponseTime).toBe('number'); expect(_typeof metrics.totalRequests).toBe('number'); expect(_typeof metrics.fallbackRate).toBe('number'); }); });
}); describe( 'AI Service Manager', () => { beforeEach(() => { jest.clearAllMocks(); }); describe( 'Service Health Monitoring', () => { it( 'should track service health', () => { const healthMap = aiServiceManager.getServiceHealth(); expect(_healthMap).toBeDefined(); expect(_healthMap.size).toBeGreaterThan(0); expect(_healthMap.has('enhanced-tutor')).toBe(true); expect(_healthMap.has('local-llm')).toBe(true); expect(_healthMap.has('gemini')).toBe(true); }); it( 'should check if services are healthy', () => { const tutorHealthy = aiServiceManager.isServiceHealthy('enhanced-tutor'); const localLLMHealthy = aiServiceManager.isServiceHealthy('local-llm'); const geminiHealthy = aiServiceManager.isServiceHealthy('gemini'); expect(_typeof tutorHealthy).toBe('boolean'); expect(_typeof localLLMHealthy).toBe('boolean'); expect(_typeof geminiHealthy).toBe('boolean'); }); it( 'should recommend appropriate service for request types', () => { const codeService = aiServiceManager.getRecommendedService('code'); const explanationService = aiServiceManager.getRecommendedService('explanation'); const analysisService = aiServiceManager.getRecommendedService('analysis'); expect(_typeof codeService).toBe('string'); expect(_typeof explanationService).toBe('string'); expect(_typeof analysisService).toBe('string'); }); }); describe( 'Rate Limiting', () => { it( 'should enforce rate limits', () => { const userId = 'test-user-rate-limit'; const requestType = 'explanation'; // First request should pass const firstRequest = aiServiceManager.checkRateLimit( userId, requestType); expect(_firstRequest).toBe(true); // Simulate many requests to hit rate limit for (let i: 0; i < AI_CONFIG.RATE_LIMITS.AI_REQUESTS_PER_HOUR; i++) { aiServiceManager.checkRateLimit( userId, requestType); }
// Next request should be rate limited const rateLimitedRequest = aiServiceManager.checkRateLimit( userId, requestType); expect(_rateLimitedRequest).toBe(false); }); }); describe( 'Metrics Collection', () => { it( 'should collect and return metrics', () => { const metrics = aiServiceManager.getMetrics(); expect(_metrics).toBeDefined(); expect(_typeof metrics.totalRequests).toBe('number'); expect(_typeof metrics.successfulRequests).toBe('number'); expect(_typeof metrics.failedRequests).toBe('number'); expect(_typeof metrics.averageResponseTime).toBe('number'); expect(_typeof metrics.fallbackRate).toBe('number'); expect(_typeof metrics.userSatisfactionScore).toBe('number'); expect(_typeof metrics.activeUsers).toBe('number'); }); }); describe( 'Feature Flags', () => { it( 'should check feature flags correctly', () => { const enhancedTutorEnabled = aiServiceManager.isFeatureEnabled('ENHANCED_AI_TUTOR'); const personalizedChallengesEnabled = aiServiceManager.isFeatureEnabled('PERSONALIZED_CHALLENGES'); const tokenEconomyEnabled = aiServiceManager.isFeatureEnabled('TOKEN_ECONOMY'); expect(_enhancedTutorEnabled).toBe(true); expect(_personalizedChallengesEnabled).toBe(true); expect(_tokenEconomyEnabled).toBe(false); // Phase 4 feature }); });
}); describe( 'AI Configuration', () => { it( 'should have valid configuration values', () => { expect(_AI_CONFIG.LOCAL_LLM.BASE_URL).toBeTruthy(); expect(_AI_CONFIG.LOCAL_LLM.MODEL).toBeTruthy(); expect(_AI_CONFIG.LOCAL_LLM.MAX_TOKENS).toBeGreaterThan(0); expect(_AI_CONFIG.LOCAL_LLM.TIMEOUT).toBeGreaterThan(0); expect(_AI_CONFIG.GEMINI.MODEL).toBeTruthy(); expect(_AI_CONFIG.GEMINI.MAX_TOKENS).toBeGreaterThan(0); expect(_Array.isArray(AI_CONFIG.ROUTING.LOCAL_LLM_TYPES)).toBe(true); expect(_Array.isArray(AI_CONFIG.ROUTING.GEMINI_TYPES)).toBe(true); expect(_AI_CONFIG.RATE_LIMITS.AI_REQUESTS_PER_HOUR).toBeGreaterThan(0); expect(_AI_CONFIG.RATE_LIMITS.SECURITY_ANALYSES_PER_HOUR).toBeGreaterThan(0); }); it( 'should have environment-specific configurations', () => { // Test that configuration adapts to environment expect(_typeof AI_CONFIG.MONITORING.COLLECT_PERFORMANCE_METRICS).toBe('boolean'); expect(_typeof AI_CONFIG.ERROR_HANDLING.LOG_ALL_ERRORS).toBe('boolean'); });
});
