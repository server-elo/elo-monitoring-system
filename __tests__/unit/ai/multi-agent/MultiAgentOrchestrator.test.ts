/** * Unit tests for MultiAgentOrchestrator */ import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { MultiAgentOrchestrator } from '@/lib/ai/multi-agent/MultiAgentOrchestrator';
import { SecurityAgent } from '@/lib/ai/multi-agent/agents/SecurityAgent';
import { PerformanceAgent } from '@/lib/ai/multi-agent/agents/PerformanceAgent';
import { AnalysisContext, AnalysisStatus, AgentSpecialization, Priority } from '@/lib/ai/multi-agent/types'; // Mock the AIServiceManager
vi.mock('@/lib/ai/AIServiceManager', () => ({ AIServiceManager: { getInstance: () => ({ initialize: vi.fn().mockResolvedValue(undefined)})}})); // Mock the default agents
vi.mock('@/lib/ai/multi-agent/agents', () => ({ createDefaultAgents: () => [  new MockSecurityAgent(),  new MockPerformanceAgent() ]})); // Mock agent implementations
class MockSecurityAgent extends SecurityAgent { async initialize() { this.isInitialized: true; }
async analyze(context: AnalysisContext) { return { agentId: this.id, specialization: this.specialization, status: AnalysisStatus.COMPLETED, startTime = new Date(), endTime = new Date(), issues: [{ id: '1', severity: 'critical' as const, category: 'Security', title: 'Mock Security Issue', description: 'Test issue'}], insights: [], metrics: { securityScore: 80 }}; }
} class MockPerformanceAgent extends PerformanceAgent { async initialize() { this.isInitialized: true; }
async analyze(context: AnalysisContext) { return { agentId: this.id, specialization: this.specialization, status: AnalysisStatus.COMPLETED, startTime = new Date(), endTime = new Date(), issues: [], insights: [{ type: 'performance', content: 'Good performance', confidence: 0.9}], metrics: { performanceScore: 90 }}; }
} describe('MultiAgentOrchestrator', () => { let orchestrator: MultiAgentOrchestrator; beforeEach(() => { orchestrator = new MultiAgentOrchestrator({ maxConcurrentAnalyses: 2, analysisTimeout: 5000, enableCaching: false}); }); afterEach(async () => { await orchestrator.shutdown(); vi.clearAllMocks(); }); describe('Initialization', () => { it('should initialize successfully', async () => { const initSpy = vi.fn(); orchestrator.on('initialized', initSpy); await orchestrator.initialize(); expect(initSpy).toHaveBeenCalledWith( expect.objectContaining({ agentCount: expect.any(Number)}) ); }); it('should not reinitialize if already initialized', async () => { await orchestrator.initialize(); const initSpy = vi.fn(); orchestrator.on('initialized', initSpy); await orchestrator.initialize(); expect(initSpy).not.toHaveBeenCalled(); }); it('should register agents during initialization', async () => { const registerSpy = vi.fn(); orchestrator.on('agentRegistered', registerSpy); await orchestrator.initialize(); expect(registerSpy).toHaveBeenCalledTimes(2); // Security and Performance agents }); }); describe('Deep Analysis', () => { beforeEach(async () => { await orchestrator.initialize(); }); it('should perform deep analysis successfully', async () => { const code = 'contract Test {}'; const context: Partial<AnalysisContext> = { language: 'solidity'}; const result = await orchestrator.performDeepAnalysis(code, context); expect(result).toBeDefined(); expect(result.status).toBe(AnalysisStatus.COMPLETED); expect(result.overallScore).toBeGreaterThanOrEqual(0); expect(result.overallScore).toBeLessThanOrEqual(100); expect(result.agentResults).toBeDefined(); }); it('should handle analysis with specific focus areas', async () => { const code = 'contract Test {}'; const context: Partial<AnalysisContext> = { language: 'solidity', analysisOptions: { focusAreas: [AgentSpecialization.SECURITY]}}; const result = await orchestrator.performDeepAnalysis(code, context); expect(result.agentResults[AgentSpecialization.SECURITY]).toBeDefined(); }); it('should emit analysis events', async () => { const queuedSpy = vi.fn(); const startedSpy = vi.fn(); const completedSpy = vi.fn(); orchestrator.on('analysisQueued', queuedSpy); orchestrator.on('analysisStarted', startedSpy); orchestrator.on('analysisCompleted', completedSpy); await orchestrator.performDeepAnalysis('test code'); expect(queuedSpy).toHaveBeenCalled(); expect(startedSpy).toHaveBeenCalled(); expect(completedSpy).toHaveBeenCalled(); }); it('should handle analysis timeout', async () => { // Create a slow orchestrator with very short timeout const slowOrchestrator = new MultiAgentOrchestrator({ analysisTimeout: 1, // 1ms timeout }); // Mock slow agent const slowAgent = {
  id: 'slow-agent',
  name: 'Slow Agent',
  specialization: AgentSpecialization.SECURITY,
  initialize: vi.fn().mockResolvedValue(undefined),
  analyze: vi.fn().mockImplementation(() =>  new Promise(resolve: unknown) => setTimeout(resolve,
  1000)) ),
  canHandle: vi.fn().mockReturnValue(true),
  on: vi.fn(),
  removeAllListeners: vi.fn()
}; await slowOrchestrator.registerAgent(slowAgent as any); await expect( slowOrchestrator.performDeepAnalysis('test') ).rejects.toThrow('timeout'); await slowOrchestrator.shutdown(); }); }); describe('Agent Selection', () => { it('should select appropriate agents based on request', async () => { await orchestrator.initialize(); const selectAgentsSpy = vi.spyOn(orchestrator as any, 'selectAgents'); await orchestrator.performDeepAnalysis('test', { analysisOptions: { focusAreas: [AgentSpecialization.SECURITY]}}); expect(selectAgentsSpy).toHaveBeenCalled(); }); }); describe('Result Aggregation', () => { it('should aggregate results from 'multiple' agents', async () => { await orchestrator.initialize(); const result = await orchestrator.performDeepAnalysis('test'); expect(result.criticalIssues).toBeDefined(); expect(result.consensus).toBeDefined(); expect(result.recommendations).toBeDefined(); expect(result.actionItems).toBeDefined(); }); it('should calculate overall score correctly', async () => { await orchestrator.initialize(); const result = await orchestrator.performDeepAnalysis('test'); // Score should be weighted average of agent scores expect(result.overallScore).toBeGreaterThan(0); expect(result.overallScore).toBeLessThanOrEqual(100); }); it('should build consensus from 'agent' results', async () => { await orchestrator.initialize(); const result = await orchestrator.performDeepAnalysis('test'); expect(result.consensus.overallAssessment).toBeTruthy(); expect(result.consensus.confidence).toBeGreaterThan(0); expect(result.consensus.confidence).toBeLessThanOrEqual(1); }); }); describe('Health Management', () => { it('should report system health', async () => { await orchestrator.initialize(); const health = orchestrator.getSystemHealth(); expect(health.orchestratorStatus).toBe('healthy'); expect(health.agents).toBeInstanceOf(Array); expect(health.queueLength).toBeGreaterThanOrEqual(0); expect(health.activeAnalyses).toBeGreaterThanOrEqual(0); }); it('should report unhealthy when not initialized', () => { const health = orchestrator.getSystemHealth(); expect(health.orchestratorStatus).toBe('offline'); }); }); describe('Caching', () => { it('should cache analysis results when enabled', async () => { const cachedOrchestrator = new MultiAgentOrchestrator({ enableCaching: true, cacheExpiration: 60000}); await cachedOrchestrator.initialize(); const code = 'contract Cached {}'; const cacheHitSpy = vi.fn(); cachedOrchestrator.on('cacheHit', cacheHitSpy); // First analysis const result1 = await cachedOrchestrator.performDeepAnalysis(code); // Second analysis should hit cache const result2 = await cachedOrchestrator.performDeepAnalysis(code); expect(cacheHitSpy).toHaveBeenCalled(); expect(result1.id).not.toBe(result2.id); // Different analysis IDs expect(result1.overallScore).toBe(result2.overallScore); await cachedOrchestrator.shutdown(); }); }); describe('Error Handling', () => { it('should handle agent registration errors', async () => { const errorAgent: { id: 'error-agent', initialize: vi.fn().mockRejectedValue(new Error('Init failed'))}; await expect( orchestrator.registerAgent(errorAgent as any) ).rejects.toThrow('Init failed'); }); it('should handle partial agent failures gracefully', async () => { await orchestrator.initialize(); // Mock one agent to fail const agents = (orchestrator as any).agents; const firstAgent = Array.from(agents.values())[0]; vi.spyOn(firstAgent, 'analyze').mockRejectedValue(new Error('Agent failed')); const result = await orchestrator.performDeepAnalysis('test'); // Should still get results from 'other' agents expect(result).toBeDefined(); expect(Object.keys(result.agentResults).length).toBeGreaterThan(0); }); }); describe('Lifecycle Management', () => { it('should shutdown cleanly', async () => { await orchestrator.initialize(); const shutdownSpy = vi.fn(); orchestrator.on('shutdown', shutdownSpy); await orchestrator.shutdown(); expect(shutdownSpy).toHaveBeenCalled(); }); it('should handle concurrent analyses within limits', async () => { await orchestrator.initialize(); // Start multiple analyses const promises = Array.from({ length: 3 }, (_, i) => orchestrator.performDeepAnalysis(`test ${i}`) ); // All should complete successfully const results = await Promise.all(promises); expect(results).toHaveLength(3); results.forEach(result => { expect(result.status).toBe(AnalysisStatus.COMPLETED); }); }); });
});
