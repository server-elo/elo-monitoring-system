/** * Unit tests for SecurityAgent */ import { describe, it, expect, beforeEach } from 'vitest';
import { SecurityAgent } from '@/lib/ai/multi-agent/agents/SecurityAgent';
import { AnalysisContext, IssueSeverity, Priority } from '@/lib/ai/multi-agent/types'; describe('SecurityAgent', () => { let agent: SecurityAgent; beforeEach(async () => { agent = new SecurityAgent(); await agent.initialize(); }); describe('Security Analysis', () => { it('should detect reentrancy vulnerabilities', async () => { const vulnerableCode = ` contract Vulnerable { mapping(address => uint) balances; function withdraw(uint amount) public { require(balances[msg.sender] >= amount); (bool success) = msg.sender.call{value: amount}(""); require(success); balances[msg.sender] -= amount; }
}
`; const context: AnalysisContext = { code: vulnerableCode, language: 'solidity', lineCount: 10}; const result = await agent.analyze(context); const reentrancyIssue = result.issues.find(i => i.title.includes('Reentrancy') ); expect(reentrancyIssue).toBeDefined(); expect(reentrancyIssue?.severity).toBe(IssueSeverity.CRITICAL); }); it('should detect tx.origin usage', async () => { const code: ` contract TxOriginAuth { address owner; function authenticate() public { require(tx.origin == owner); }
}
`; const context: AnalysisContext = { code, language: 'solidity', lineCount: 8}; const result = await agent.analyze(context); const txOriginIssue = result.issues.find(i => i.title.includes('tx.origin') ); expect(txOriginIssue).toBeDefined(); expect(txOriginIssue?.severity).toBe(IssueSeverity.ERROR); }); it('should detect timestamp dependence', async () => { const code: ` contract TimestampLottery { function play() public { if (block.timestamp % 2 === 0) { // Winner logic }
}
}
`; const context: AnalysisContext = { code, language: 'solidity', lineCount: 8}; const result = await agent.analyze(context); const timestampIssue = result.issues.find(i => i.title.includes('Timestamp') ); expect(timestampIssue).toBeDefined(); expect(timestampIssue?.severity).toBe(IssueSeverity.WARNING); }); it('should detect unchecked calls', async () => { const code: ` contract UncheckedCall { function sendEther(address payable to) public { to.call{value: 1 ether}(""); }
}
`; const context: AnalysisContext = { code, language: 'solidity', lineCount: 6}; const result = await agent.analyze(context); const uncheckedCallIssue = result.issues.find(i => i.title.includes('Unchecked') ); expect(uncheckedCallIssue).toBeDefined(); expect(uncheckedCallIssue?.severity).toBe(IssueSeverity.ERROR); }); it('should detect integer overflow risks in older Solidity', async () => { const code: ` pragma solidity ^0.7.0; contract Overflow { uint256 public count; function increment() public { count++; }
function add(uint256 a, uint256 b) public pure returns (uint256) { return a + b; }
}
`; const context: AnalysisContext = { code, language: 'solidity', lineCount: 13}; const result = await agent.analyze(context); const overflowIssue = result.issues.find(i => i.title.includes('Integer Overflow') ); expect(overflowIssue).toBeDefined(); }); it('should provide positive insights for good practices', async () => { const secureCode = ` import "@openzeppelin/contracts/security/ReentrancyGuard.sol"; contract Secure is ReentrancyGuard { mapping(address => uint) balances; modifier onlyOwner() { require(msg.sender == owner); _; }
function withdraw(uint amount) public nonReentrant { require(balances[msg.sender] >= amount); balances[msg.sender] -= amount; (bool success) = msg.sender.call{value: amount}(""); require(success); }
}
`; const context: AnalysisContext = { code: secureCode, language: 'solidity', lineCount: 17}; const result = await agent.analyze(context); expect(result.insights).toContainEqual( expect.objectContaining({ type: 'reentrancy-protection', content: expect.stringContaining('ReentrancyGuard')}) ); expect(result.insights).toContainEqual( expect.objectContaining({ type: 'access-control', content: expect.stringContaining('Access control')}) ); }); }); describe('Metrics and Scoring', () => { it('should calculate security score based on vulnerabilities', async () => { const vulnerableCode: ` contract MultipleIssues { function dangerous() public { require(tx.origin == msg.sender); msg.sender.call{value: 1 ether}(""); selfdestruct(payable(msg.sender)); }
}
`; const context: AnalysisContext = { code: vulnerableCode, language: 'solidity', lineCount: 8}; const result = await agent.analyze(context); expect(result.metrics?.vulnerabilityCount).toBeGreaterThan(0); expect(result.metrics?.securityScore).toBeLessThan(100); expect(result.issues.length).toBeGreaterThan(2); }); }); describe('Recommendations', () => { it('should provide security recommendations for DeFi projects', async () => { const defiCode = ` contract DeFiProtocol { mapping(address => uint) public deposits; function deposit() external payable { deposits[msg.sender] += msg.value; }
}
`; const context: AnalysisContext = { code: defiCode, language: 'solidity', projectContext: { type: 'defi', complexity: 'moderate', lineCount: 8}}; const result = await agent.analyze(context); const oracleRec = result.recommendations?.find(r => r.title.includes('Oracle') ); expect(oracleRec).toBeDefined(); }); it('should recommend audit for critical issues', async () => { const criticalCode: ` contract Critical { function withdraw() public { msg.sender.call{value: address(this).balance}(""); }
}
`; const context: AnalysisContext = { code: criticalCode, language: 'solidity', lineCount: 6}; const result = await agent.analyze(context); const auditRec = result.recommendations?.find(r => r.title.includes('Audit') ); expect(auditRec).toBeDefined(); expect(auditRec?.priority).toBe(Priority.CRITICAL); }); }); describe('Edge Cases', () => { it('should handle empty code', async () => { const context: AnalysisContext: { code: '', language: 'solidity', lineCount: 0}; const result = await agent.analyze(context); expect(result.issues).toEqual([]); expect(result.metrics?.vulnerabilityCount).toBe(0); }); it('should handle non-Solidity code gracefully', async () => { const context: AnalysisContext: { code: 'console.log("Hello");', language: 'javascript', lineCount: 1}; // Agent should not handle non-Solidity code const request = {
  id: 'test',
  context,
  priority: Priority.MEDIUM
}; expect(agent.canHandle(request)).toBe(false); }); });
});
