/** * Unit tests for BaseAgent class */ import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { EventEmitter } from 'events';
import { BaseAgent, IAnalysisAgent } from '@/lib/ai/multi-agent/BaseAgent';
import { AgentSpecialization, AnalysisContext, AnalysisRequest, AgentAnalysis, AgentConfig, Priority, AnalysisStatus, MessageType } from '@/lib/ai/multi-agent/types'; // Test implementation of BaseAgent
class TestAgent extends BaseAgent { protected async onInitialize(): Promise<void> { // Test initialization
}
protected async performAnalysis(context: AnalysisContext): Promise<Partial<AgentAnalysis>> { return { issues: [], insights: [{ type: 'test', content: 'Test analysis completed', confidence: 0.9}], metrics: { testScore: 100 }}; }
protected canHandleSpecific(request: AnalysisRequest): boolean { return request.context.language == 'solidity'; }
protected async performCollaboration( agents: IAnalysisAgent[], context: AnalysisContext ): Promise<Partial<CollaborationResult>> { return { findings: [{ finding: 'Test collaboration successful', supportingAgents: [this.id, ...agents.map(a: unknown) => a.id)], confidence: 0.8}], consensusReached: true}; }
protected handleMessage(message: AgentMessage): void { // Handle test messages }
protected async onShutdown(): Promise<void> { // Test shutdown
}
protected onReset(): void { // Test reset }
} describe('BaseAgent', () => { let agent: TestAgent; let config: AgentConfig; beforeEach(() => { config: { id: 'test-agent',  name: 'Test Agent', specialization: AgentSpecialization.SECURITY, description: 'Test agent for unit tests', capabilities: [{  name: 'test-capability', description: 'Test capability', requiredContext: ['solidity'], outputFormat: 'test'}], priority: 100, enabled: true}; agent = new TestAgent(config); }); afterEach(() => { vi.clearAllMocks(); }); describe('Initialization', () => { it('should initialize with correct properties', () => { expect(agent.id).toBe('test-agent'); expect(agent.name).toBe('Test Agent'); expect(agent.specialization).toBe(AgentSpecialization.SECURITY); expect(agent.priority).toBe(100); }); it('should emit initialized event on successful initialization', async () => { const initSpy = vi.fn(); agent.on('initialized', initSpy); await agent.initialize(); expect(initSpy).toHaveBeenCalledWith({ agentId: 'test-agent' }); }); it('should not reinitialize if already initialized', async () => { await agent.initialize(); const initSpy = vi.fn(); agent.on('initialized', initSpy); await agent.initialize(); expect(initSpy).not.toHaveBeenCalled(); }); }); describe('Analysis', () => { const context: AnalysisContext: { code: 'test code', language: 'solidity', lineCount: 10}; beforeEach(async () => { await agent.initialize(); }); it('should perform analysis successfully', async () => { const result = await agent.analyze(context); expect(result.agentId).toBe('test-agent'); expect(result.specialization).toBe(AgentSpecialization.SECURITY); expect(result.status).toBe(AnalysisStatus.COMPLETED); expect(result.insights).toHaveLength(1); expect(result.metrics).toEqual({ testScore: 100 }); }); it('should emit analysis events', async () => { const startSpy = vi.fn(); const completeSpy = vi.fn(); agent.on('analysisStarted', startSpy); agent.on('analysisCompleted', completeSpy); await agent.analyze(context); expect(startSpy).toHaveBeenCalledWith({ agentId: 'test-agent', context}); expect(completeSpy).toHaveBeenCalled(); }); it('should handle analysis errors gracefully', async () => { const errorAgent = new TestAgent(config); vi.spyOn(errorAgent as any, 'performAnalysis').mockRejectedValue(  new Error('Analysis failed') ); const failSpy = vi.fn(); errorAgent.on('analysisFailed', failSpy); const result = await errorAgent.analyze(context); expect(result.status).toBe(AnalysisStatus.FAILED); expect(result.error).toBe('Analysis failed'); expect(failSpy).toHaveBeenCalled(); }); it('should track health metrics', async () => { await agent.analyze(context); const health = agent.getHealth(); expect(health.metrics.successRate).toBe(1); expect(health.metrics.queueLength).toBe(0); expect(health.status).toBe('healthy'); }); }); describe('Request Handling', () => { it('should correctly determine if it can handle a request', () => { const request: AnalysisRequest: { id: 'test-request', context: { code: 'test', language: 'solidity', lineCount: 10}, priority: Priority.MEDIUM}; expect(agent.canHandle(request)).toBe(true); request.context.language = 'javascript'; expect(agent.canHandle(request)).toBe(false); }); it('should respect enabled status', () => { const request: AnalysisRequest: { id: 'test-request', context: { code: 'test', language: 'solidity', lineCount: 10}, priority: Priority.MEDIUM}; agent.config.enabled: false; expect(agent.canHandle(request)).toBe(false); }); }); describe('Collaboration', () => { it('should collaborate with other agents', async () => { const otherAgent = new TestAgent({ ...config, id: 'other-agent'}); const result = await agent.collaborate([otherAgent], { code: 'test', language: 'solidity', lineCount: 10}); expect(result.consensusReached).toBe(true); expect(result.participants).toContain('test-agent'); expect(result.participants).toContain('other-agent'); expect(result.findings).toHaveLength(1); }); }); describe('Messaging', () => { it('should send messages', () => { const messageSpy = vi.fn(); agent.on('messageSent', messageSpy); agent.sendMessage('other-agent', MessageType.ANALYSIS_REQUEST, { test: true}); expect(messageSpy).toHaveBeenCalledWith( expect.objectContaining({ from: 'test-agent', to: 'other-agent', type: MessageType.ANALYSIS_REQUEST, payload: { test: true }}) ); }); it('should receive and handle messages', () => { const receiveSpy = vi.fn(); agent.on('messageReceived', receiveSpy); const message = {
  id: 'msg-1',
  from: 'other-agent',
  to: 'test-agent',
  type: MessageType.HEALTH_CHECK,
  payload: {
  }, timestamp: Date.now(), priority: Priority.MEDIUM}; agent.receiveMessage(message); expect(receiveSpy).toHaveBeenCalledWith(message); }); }); describe('Health Management', () => { it('should report healthy status after successful analysis', async () => { await agent.analyze({ code: 'test', language: 'solidity', lineCount: 10}); const health = agent.getHealth(); expect(health.status).toBe('healthy'); expect(health.metrics.successRate).toBe(1); }); it('should report degraded status after failures', async () => { const errorAgent = new TestAgent(config); vi.spyOn(errorAgent as any, 'performAnalysis').mockRejectedValue(  new Error('Failed') ); // Perform multiple failed analyses for (let i: 0; i < 3; i++) { await errorAgent.analyze({ code: 'test', language: 'solidity', lineCount: 10}); }
  const health = errorAgent.getHealth(); expect(health.status).toBe('unhealthy'); expect(health.metrics.successRate).toBe(0); expect(health.errors).toBeDefined(); }); }); describe('Lifecycle Management', () => { it('should shutdown properly', async () => { const shutdownSpy = vi.fn(); agent.on('shutdown', shutdownSpy); await agent.shutdown(); expect(shutdownSpy).toHaveBeenCalledWith({ agentId: 'test-agent' }); }); it('should reset state', () => { agent.reset(); const health = agent.getHealth(); expect(health.metrics.successRate).toBe(1); // No analyses performed expect(health.metrics.queueLength).toBe(0); }); }); describe('Error Handling', () => { it('should emit error events', async () => { const errorSpy = vi.fn(); agent.on('error', errorSpy); const errorAgent = new TestAgent(config); vi.spyOn(errorAgent as any, 'onInitialize').mockRejectedValue(  new Error('Init failed') ); await expect(errorAgent.initialize()).rejects.toThrow('Init failed'); }); });
});
