/** * Integration tests for Multi-Agent Analysis API */ import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
import { NextRequest } from 'next/server';
import { POST as multiAgentPost, GET as multiAgentGet } from '@/app/api/ai/multi-agent-analysis/route';
import { POST as quickPost } from '@/app/api/ai/quick-analysis/route'; // Mock auth
vi.mock('@/lib/auth/config', () => ({ auth: vi.fn().mockResolvedValue({ user: { id: 'test-user-123', email: 'test@example.com' }})})); // Mock rate limiting
vi.mock('@/lib/api/rateLimit', () => ({ rateLimit: vi.fn().mockResolvedValue({ allowed: true, remaining: 10})})); // Mock Redis
vi.mock('@/lib/cache/redis-client', () => ({ getRedisClient: () => ({ get: vi.fn().mockResolvedValue(null), setex: vi.fn().mockResolvedValue('OK'), hincrby: vi.fn().mockResolvedValue(1), hget: vi.fn().mockResolvedValue('5')})})); // Mock MultiAgentOrchestrator
vi.mock('@/lib/ai/multi-agent/MultiAgentOrchestrator', () => ({ MultiAgentOrchestrator: vi.fn().mockImplementation(() => ({ initialize: vi.fn().mockResolvedValue(undefined), performDeepAnalysis: vi.fn().mockResolvedValue({ id: 'analysis-123', timestamp: new Date(), overallScore: 85, status: 'completed', criticalIssues: [{ id: 'issue-1', severity: 'critical', category: 'Security', title: 'Reentrancy Vulnerability', description: 'External call before state change'}], agentResults: { security: { agentId: 'security-agent', specialization: 'security', status: 'completed', issues: [], insights: [], metrics: {}}}, consensus: { overallAssessment: 'Code has critical security issues', keyFindings: ['Reentrancy vulnerability detected'], confidence: 0.9}, recommendations: [{ id: 'rec-1', priority: 'high', category: 'Security', title: 'Fix Reentrancy', description: 'Apply checks-effects-interactions pattern', impact: 'Critical security improvement', effort: 'medium'}], actionItems: []}), getSystemHealth: vi.fn().mockReturnValue({ orchestratorStatus: 'healthy', agents: [], queueLength: 0, activeAnalyses: 1})}))})); describe('Multi-Agent Analysis API', () => { describe('POST /api/ai/multi-agent-analysis', () => { it('should perform deep analysis successfully', async () => { const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'contract Test { function withdraw() external {} }', language: 'solidity', analysisDepth: 'deep'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(200); expect(data.success).toBe(true); expect(data.data).toMatchObject({ id: 'analysis-123', overallScore: 85, criticalIssues: expect.any(Array)}); }); it('should validate request body', async () => { const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ // Missing required 'code' field, language: 'solidity'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(400); expect(data.success).toBe(false); expect(data.error).toBeDefined(); }); it('should handle authentication errors', async () => { // Mock auth to return null const { auth } = await import('@/lib/auth/config'); vi.mocked(auth).mockResolvedValueOnce(null); const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'test', language: 'solidity'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(401); expect(data.success).toBe(false); }); it('should handle rate limiting', async () => { // Mock rate limit to deny const { rateLimit } = await import('@/lib/api/rateLimit'); vi.mocked(rateLimit).mockResolvedValueOnce({ allowed: false, remaining: 0, resetIn: 3600}); const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'test', language: 'solidity'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(429); expect(data.success).toBe(false); expect(data.error).toContain('Rate limit'); }); it('should use cache when available', async () => { // Mock Redis to return cached result const { getRedisClient } = await import('@/lib/cache/redis-client'); const mockRedis = getRedisClient(); vi.mocked(mockRedis.get).mockResolvedValueOnce(JSON.stringify({ id: 'cached-analysis', overallScore: 90})); const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'cached code', language: 'solidity'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(200); expect(data.meta.cached).toBe(true); expect(data.data.id).toBe('cached-analysis'); }); }); describe('GET /api/ai/multi-agent-analysis', () => { it('should return system health and capabilities', async () => { const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'GET'}); const response = await multiAgentGet(request); const data = await response.json(); expect(response.status).toBe(200); expect(data.success).toBe(true); expect(data.data).toMatchObject({ status: 'operational', health: expect.objectContaining({ orchestratorStatus: 'healthy'}), capabilities: expect.objectContaining({ languages: expect.arrayContaining(['solidity']), agents: expect.any(Array)})}); }); }); describe('POST /api/ai/quick-analysis', () => { it('should perform quick analysis successfully', async () => { const request = new NextRequest(',
http://localhost:3000/api/ai/quick-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'contract Quick {}', language: 'solidity', focusArea: 'security'})}); const response = await quickPost(request); const data = await response.json(); expect(response.status).toBe(200); expect(data.success).toBe(true); expect(data.data).toMatchObject({ analysisId: expect.any(String), score: expect.any(Number), executionTime: expect.any(Number)}); }); it('should handle different focus areas', async () => { const focusAreas = ['security', 'performance', 'quality']; for (const focusArea of focusAreas) { const request = new NextRequest(',
http://localhost:3000/api/ai/quick-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'test code', language: 'solidity', focusArea})}); const response = await quickPost(request); const data = await response.json(); expect(response.status).toBe(200); expect(data.meta.focusArea).toBe(focusArea); }
}); it('should enforce smaller code size limit', async () => { const largeCode = 'x'.repeat(15000); // Exceeds 10k limit const request = new NextRequest(',
http://localhost:3000/api/ai/quick-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: largeCode, language: 'solidity'})}); const response = await quickPost(request); const data = await response.json(); expect(response.status).toBe(400); expect(data.success).toBe(false); }); it('should handle analysis timeouts', async () => { // Mock orchestrator to simulate timeout const { MultiAgentOrchestrator } = await import('@/lib/ai/multi-agent/MultiAgentOrchestrator'); const mockPerformDeepAnalysis = vi.fn().mockRejectedValue(new Error('Analysis timeout')); vi.mocked(MultiAgentOrchestrator).mockImplementationOnce(() => ({ initialize: vi.fn(), performDeepAnalysis: mockPerformDeepAnalysis} as any)); const request = new NextRequest(',
http://localhost:3000/api/ai/quick-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'timeout test', language: 'solidity'})}); const response = await quickPost(request); const data = await response.json(); expect(response.status).toBe(500); expect(data.error).toContain('timeout'); }); }); describe('Error Scenarios', () => { it('should handle orchestrator initialization errors', async () => { const { MultiAgentOrchestrator } = await import('@/lib/ai/multi-agent/MultiAgentOrchestrator'); vi.mocked(MultiAgentOrchestrator).mockImplementationOnce(() => ({ initialize: vi.fn().mockRejectedValue(new Error('Init failed'))} as any)); const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'test', language: 'solidity'})}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(500); expect(data.success).toBe(false); }); it('should handle invalid language parameter', async () => { const request = new NextRequest(',
http://localhost:3000/api/ai/multi-agent-analysis', { method: 'POST', headers: { 'Content-Type': 'application/json'}, body: JSON.stringify({ code: 'test', language: 'python', // Not supported })}); const response = await multiAgentPost(request); const data = await response.json(); expect(response.status).toBe(400); expect(data.success).toBe(false); }); });
});
